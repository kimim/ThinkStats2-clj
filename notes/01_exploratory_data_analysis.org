In this chapter, Allen Downey introduces the statistic data in Stata dictionary
format. Thus we need to decode the data in Clojure firstly.

#+begin_src clojure :results silent
(ns thinkstats2.exploratory-data-analaysis
  (:require [clj-http.client :as client]
            [clojure.java.io :as io]
            [clojure.string :as str])
  (:import java.util.zip.GZIPInputStream))
#+end_src

* Get the data from CDC

#+begin_src clojure :results pp :exports both
(defn fetch-data! [url]
  (let [req (client/get url {:as :byte-array :throw-exceptions false})]
    (if (= (:status req) 200)
      (-> (:body req)
          (io/copy (io/file (last (str/split url #"/"))))))))

(fetch-data! "https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Datasets/NSFG/stata/2002FemPreg.dct")
(fetch-data! "https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Datasets/NSFG/2002FemPreg.dat")
#+end_src

#+RESULTS:
: nil

* Parse the data

Ray Miller already did this work, so let's reuse it [fn:1].

The format of a ~.dct~ file looks like this:
#+begin_example
infile dictionary {
    _column(1)      str12                             caseid  %12s  "RESPONDENT ID NUMBER"
   _column(13)       byte                           pregordr   %2f  "PREGNANCY ORDER (NUMBER)"
   ...
   }
#+end_example

It is easy to extract lines with regex:

#+begin_src clojure :results pp :exports both
(def dict-line-rx #"^\s+_column\((\d+)\)\s+(\S+)\s+(\S+)\s+%(\d+)(\S)\s+\"([^\"]+)\"")
(def line (with-open [r (io/reader "2002FemPreg.dct")]
            (first (rest (line-seq r)))))
line
#+end_src

#+RESULTS:
: "    _column(1)      str12                             caseid  %12s  \"RESPONDENT ID NUMBER\""

#+begin_src clojure :results pp :exports both
(re-find dict-line-rx line)
#+end_src

#+RESULTS:
: ["    _column(1)      str12                             caseid  %12s  \"RESPONDENT ID NUMBER\""
:  "1"
:  "str12"
:  "caseid"
:  "12"
:  "s"
:  "RESPONDENT ID NUMBER"]

#+begin_src clojure :results pp :exports both
(require '[clojure.string :as str])
(defn parse-dict-line
  [line]
  (try (let [[_ col type name f-len f-spec descr] (re-find dict-line-rx line)]
         {:col    (dec (Integer/parseInt col))
          :type   type
          :name   (str/replace name "_" "-")
          :f-len  (Integer/parseInt f-len)
          :f-spec f-spec
          :descr  descr})
       (catch Exception e (println line))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/parse-dict-line

#+begin_src clojure :results pp :exports both
(parse-dict-line line)
#+end_src

#+RESULTS:
: {:col 0,
:  :type "str12",
:  :name "caseid",
:  :f-len 12,
:  :f-spec "s",
:  :descr "RESPONDENT ID NUMBER"}

#+begin_src clojure :results pp :exports both
(defn read-dict-defn
  "Read a Stata dictionary file, return a vector of column definitions."
  [path]
  (with-open [r (io/reader path)]
    (mapv parse-dict-line (butlast (rest (line-seq r))))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/read-dict-defn

#+begin_src clojure :results pp :exports both
(def dict (read-dict-defn "2002FemPreg.dct"))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/dict

#+begin_src clojure :results pp :exports both
(count dict)
#+end_src

#+RESULTS:
: 243

#+begin_src clojure :results pp :exports both
(defn parse-value
  [type raw-value]
  (when (not (empty? raw-value))
    (case type
      ("str12")          raw-value
      ("byte" "int")     (Long/parseLong raw-value)
      ("float" "double") (Double/parseDouble raw-value))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/parse-value

#+begin_src clojure :results pp :exports both
(defn make-row-parser
  "Parse a row from a Stata data file according to the specification in `dict`.
   Return a vector of columns."
  [dict]
  (fn [row]
    (reduce (fn [accum {:keys [col type name f-len]}]
              (let [raw-value (str/trim (subs row col (+ col f-len)))]
                (conj accum (parse-value type raw-value))))
            []
            dict)))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/make-row-parser

#+begin_src clojure :results pp :exports both
(defn reader
  "Open path with io/reader; coerce to a GZIPInputStream if suffix is .gz"
  [path]
  (if (.endsWith path ".gz")
    (io/reader (GZIPInputStream. (io/input-stream path)))
    (io/reader path)))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/reader

#+begin_src clojure :results pp :exports both
(defn read-dct-data
  "Parse lines from `rdr` according to the specification in `dict`.
   Return a lazy sequence of parsed rows."
  [dict rdr]
  (let [parse-fn (make-row-parser dict)]
    (map parse-fn (line-seq rdr))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/read-dct-data

#+begin_src clojure :results pp :exports both
(defn as-dataset
  "Read Stata data set, return an Incanter dataset."
  [dict-path data-path]
  (let [dict   (read-dict-defn dict-path)
        header (map (comp keyword :name) dict)]
    (with-open [r (reader data-path)]
      (first (doall (read-dct-data dict r))))))

(as-dataset "2002FemPreg.dct" "2002FemPreg.dat")
#+end_src

#+RESULTS:
#+begin_example
["1"
 1
 nil
 nil
 nil
 nil
 6
 nil
 1
 nil
 nil
 1
 1093
 nil
 1084
 nil
 nil
 9
 0
 39
 9
 nil
 nil
 nil
 0
 nil
 nil
 1
 8
 13
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 1093
 138
 37
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 1
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 5
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 1166
 1093
 1166
 920
 1093
 nil
 nil
 nil
 nil
 1
 1
 1
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 3
 nil
 nil
 1
 nil
 nil
 1
 2
 nil
 nil
 1
 1
 nil
 nil
 nil
 nil
 nil
 nil
 nil
 5
 39
 1
 1
 1093
 3316
 1084
 3241
 1
 2
 1
 1
 nil
 nil
 nil
 2
 995
 nil
 1
 2
 1
 2
 695
 44
 44
 1
 1
 16
 12
 2
 2
 2
 2
 2
 2
 2
 2
 469
 3
 2
 1
 5
 nil
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
 3410.3893993529427
 3869.3496019830486
 6448.271111704751
 2
 9
 1231]
#+end_example

* Dataset




* Footnotes

[fn:1] https://tech.metail.com/think-stats-in-clojure-i/
