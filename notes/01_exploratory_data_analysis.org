#+TITLE: Chapter 01 Exploratory Data Analysis

In this chapter, Allen Downey introduces the statistic data in Stata dictionary
format. Thus we need to decode the data in Clojure first.

We'll put all the needed namespaces in the begining:

#+begin_src clojure :results silent
(ns thinkstats2.exploratory-data-analaysis
  (:require [clj-http.client :as client]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [tech.v3.dataset :as ds]
            [tablecloth.api :as api])
  (:import java.util.zip.GZIPInputStream))
#+end_src

* Get the data from CDC

Data used in chapter 1 is from CDC. I do not want to keep a local copy in
github(reduce clone time and save spaces for github), so we will download the
needed data from CDC. ~fetch-data!~ is a function to fetch data file from URL,
and put it to top folder. ~2002FemPreg.dct~ is the Stata dictionary definition
file, and ~20202FemPreg.dat~ is the data file.

#+begin_src clojure :results pp :exports both
(defn fetch-data! [url]
  (let [req (client/get url {:as :byte-array :throw-exceptions false})]
    (if (= (:status req) 200)
      (-> (:body req)
          (io/copy (io/file (last (str/split url #"/"))))))))

(fetch-data! "https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Datasets/NSFG/stata/2002FemPreg.dct")
(fetch-data! "https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Datasets/NSFG/2002FemPreg.dat")
#+end_src

#+RESULTS:
: nil

* Parse the data

Ray Miller already did this work, so let's reuse it [fn:1].

The format of a ~.dct~ file looks like this:

#+begin_example
infile dictionary {
    _column(1)      str12                             caseid  %12s  "RESPONDENT ID NUMBER"
   _column(13)       byte                           pregordr   %2f  "PREGNANCY ORDER (NUMBER)"
   ...
   }
#+end_example

It is easy to extract lines with regex:

#+begin_src clojure :results pp :exports both
(def dict-line-rx #"^\s+_column\((\d+)\)\s+(\S+)\s+(\S+)\s+%(\d+)(\S)\s+\"([^\"]+)\"")
(def line (with-open [r (io/reader "2002FemPreg.dct")]
            (first (rest (line-seq r)))))
line
#+end_src

#+RESULTS:
: "    _column(1)      str12                             caseid  %12s  \"RESPONDENT ID NUMBER\""
:

#+begin_src clojure :results pp :exports both
(re-find dict-line-rx line)
#+end_src

#+RESULTS:
: ["    _column(1)      str12                             caseid  %12s  \"RESPONDENT ID NUMBER\""
:  "1"
:  "str12"
:  "caseid"
:  "12"
:  "s"
:  "RESPONDENT ID NUMBER"]
:

Then we define ~parse-dict-line~ to extract a key mapped info from one line:

#+begin_src clojure :results pp :exports both
(defn parse-dict-line
  [line]
  (try (let [[_ col type name f-len f-spec descr] (re-find dict-line-rx line)]
         {:col    (dec (Integer/parseInt col))
          :type   type
          :name   (str/replace name "_" "-")
          :f-len  (Integer/parseInt f-len)
          :f-spec f-spec
          :descr  descr})
       (catch Exception e (println line))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/parse-dict-line
:

#+begin_src clojure :results pp :exports both
(parse-dict-line line)
#+end_src

#+RESULTS:
: {:col 0,
:  :type "str12",
:  :name "caseid",
:  :f-len 12,
:  :f-spec "s",
:  :descr "RESPONDENT ID NUMBER"}
:



#+begin_src clojure :results pp :exports both
(defn read-dict-defn
  "Read a Stata dictionary file, return a vector of column definitions."
  [path]
  (with-open [r (io/reader path)]
    (mapv parse-dict-line (butlast (rest (line-seq r))))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/read-dict-defn
:

#+begin_src clojure :results pp :exports both
(def dict (read-dict-defn "2002FemPreg.dct"))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/dict
:


#+begin_src clojure :results pp :exports both
(count dict)
#+end_src

#+RESULTS:
: 243
:

#+begin_src clojure :results pp
(take 2 dict)
#+end_src

#+RESULTS:
#+begin_example
({:col 0,
  :type "str12",
  :name "caseid",
  :f-len 12,
  :f-spec "s",
  :descr "RESPONDENT ID NUMBER"}
 {:col 12,
  :type "byte",
  :name "pregordr",
  :f-len 2,
  :f-spec "f",
  :descr "PREGNANCY ORDER (NUMBER)"})

#+end_example

#+begin_src clojure :results pp :exports both
(defn parse-value
  [type raw-value]
  (when (not (empty? raw-value))
    (case type
      ("str12")          raw-value
      ("byte" "int")     (Long/parseLong raw-value)
      ("float" "double") (Double/parseDouble raw-value))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/parse-value
:

#+begin_src clojure :results pp :exports both
(defn make-row-parser
  "Parse a row from a Stata data file according to the specification in `dict`.
   Return a vector of columns."
  [dict]
  (fn [row]
    (reduce (fn [accum {:keys [col type name f-len]}]
              (let [raw-value (str/trim (subs row col (+ col f-len)))]
                (conj accum (parse-value type raw-value))))
            []
            dict)))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/make-row-parser
:

#+begin_src clojure :results pp :exports both
(defn reader
  "Open path with io/reader; coerce to a GZIPInputStream if suffix is .gz"
  [path]
  (if (.endsWith path ".gz")
    (io/reader (GZIPInputStream. (io/input-stream path)))
    (io/reader path)))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/reader
:

#+begin_src clojure :results pp :exports both
(defn read-dct-data
  "Parse lines from `rdr` according to the specification in `dict`.
   Return a lazy sequence of parsed rows."
  [dict rdr]
  (let [parse-fn (make-row-parser dict)]
    (map parse-fn (line-seq rdr))))
#+end_src

#+RESULTS:
: #'thinkstats2.exploratory-data-analaysis/read-dct-data
:

#+begin_src clojure :results pp :exports both
(defn as-dataset
  "Read Stata data set, return an Incanter dataset."
  [dict-path data-path]
  (let [dict   (read-dict-defn dict-path)
        header (map (comp keyword :name) dict)]
    (with-open [r (reader data-path)]
      (api/dataset (read-dct-data dict r)
                   {:layout :as-rows
                    :column-names header
                    :dataset-name "2002FemPreg"}))))

(def fempreg-ds (as-dataset "2002FemPreg.dct" "2002FemPreg.dat"))
(ds/select-by-index fempreg-ds [0 1 2 3] [1 2 3])
#+end_src

#+RESULTS:
: :_unnamed [3 4]:
:
: | :caseid | :pregordr | :howpreg-n | :howpreg-p |
: |---------|----------:|-----------:|-----------:|
: |       1 |         2 |            |            |
: |       2 |         1 |            |            |
: |       2 |         2 |            |            |
:
:


#+begin_src clojure :results pp
(ds/select-by-index fempreg-ds [0 1] [1 2 3 4 5])
#+end_src

#+RESULTS:
#+begin_example
:_unnamed [5 2]:

| :caseid | :pregordr |
|---------|----------:|
|       1 |         2 |
|       2 |         1 |
|       2 |         2 |
|       2 |         3 |
|       6 |         1 |
#+end_example

* Dataset


* Footnotes

[fn:1] https://tech.metail.com/think-stats-in-clojure-i/
