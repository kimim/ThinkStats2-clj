#+TITLE: Chapter 3 Probability mass functions

#+begin_src clojure :results silent
(ns thinkstats2.pmfs
  (:require [clj-http.client :as client]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [tech.v3.dataset :as ds]
            [tech.v3.datatype.functional :as dfn]
            [tablecloth.api :as api]
            [thinkstats2-clj.nsfg :as nsfg]
            [thinkstats2-clj.chart :as chart])
  (:import java.util.zip.GZIPInputStream))
#+end_src

* Pmfs

Another way to represent a distribution is a *probability mass function(PMF)*,
which maps from each value to its probability.

A *probability* is a frequency expressed as a fraction of the sample size, $n$. To
get from frequencies to probabilities, we divide through by $n$, which is called
*normalization*.

We can map the division to each frequencies to get the probability:

#+begin_src clojure :results pp :exports both
(def v1 [1 2 2 3 5 ])
(def n (count v1))
(def hist (frequencies v1))
(->> hist
     (map #(vec [(first %) (/ (second %) n)]))
     (into {}))
#+end_src

#+RESULTS:
: {1 1/5, 2 2/5, 3 1/5, 5 1/5}
:

We can define a function ~probabilities~ to get the result:

#+begin_src clojure :results pp :exports both
(defn probabilities [coll]
  (let [n (count coll)]
    (->> coll
         frequencies
         (map #(vec [(first %) (/ (second %) n)]))
         (into {}))))

(probabilities [1 2 2 3 5])
#+end_src

#+RESULTS:
: {1 1/5, 2 2/5, 3 1/5, 5 1/5}
:

The ~probabilities~ is normalized so total probability is 1:

#+begin_src clojure :results pp :exports both
(->> [1 2 2 3 5]
     probabilities
     (map second)
     (reduce +))
#+end_src

#+RESULTS:
: 1N
:

In clojure implementation, ~frequencies~ and ~probabilities~ has no difference,
except that the value is integer and fraction respectively.

To look up the probability associated with a value, use the value as key:

#+begin_src clojure :results pp :exports both
(def prob (probabilities [1 2 2 3 5]))
(prob 2)
#+end_src

#+RESULTS:
: 2/5
:

You cannot modify an existing map, but you will get a new one:

#+begin_src clojure :results pp :exports both
(def prob1 (update prob 2 + 0.2))
(prob1 2)
#+end_src

#+RESULTS:
: 0.6000000000000001
:

Or you can multiply a probability by a factor:

#+begin_src clojure :results pp :exports both
(def prob2 (update prob1 2 * 0.5))
(prob2 2)
#+end_src

#+RESULTS:
: 0.30000000000000004
:


Now the the result is not normalized; that is, the probabilities no longer add
up to 1. To check, you can summarize the values:

#+begin_src clojure :results pp :exports both
(->> prob2
     (map second)
     (reduce +))
#+end_src

#+RESULTS:
: 0.8999999999999999
:

To normalize:

#+begin_src clojure :results pp :exports both
(defn normalize [probmap]
  (let [sum (->> probmap
                 (map second)
                 (reduce +))]
    (reduce #(update %1 %2 / sum) probmap (keys probmap))))
(->> (normalize prob2)
     (map second)
     (reduce +))
#+end_src

#+RESULTS:
: 1.0000000000000002
:

* Plotting PMFs

We can plot PMFs in both bar graph and step graph.

#+begin_src clojure :results none
(def fempreg-ds (nsfg/as-dataset "2002FemPreg.dct" "2002FemPreg.dat"))
(def firsts-pmf (-> fempreg-ds
                    (ds/filter #(and (= 1 (:outcome %))
                                     (= 1 (:birthord %))
                                     (< 27 (:prglngth %) 46)))
                    :prglngth
                    probabilities))
(def others-pmf (-> fempreg-ds
                    (ds/filter #(and (= 1 (:outcome %))
                                     (not= 1 (:birthord %))
                                     (< 27 (:prglngth %) 46)))
                    :prglngth
                    probabilities))
#+end_src

#+begin_src clojure :results file :file ../first-other-prob-histogram.svg  :exports both
(chart/histogram (chart/normalize {"first" firsts-pmf "other" others-pmf})
                 :filename "first-other-prob-histogram.svg")
#+end_src

#+RESULTS:
[[file:../first-other-prob-histogram.svg]]

#+begin_src clojure :results file :file ../first-other-prob-step.svg  :exports both
(chart/step (chart/normalize {"first" firsts-pmf "other" others-pmf})
                 :filename "first-other-prob-step.svg")
#+end_src

#+RESULTS:
[[file:../first-other-prob-step.svg]]

* Other visualizations

Because firsts and others a quite close, it makes sense to zoom in on the
difference, as show in figure [[diffs]]:

#+begin_src clojure :results pp :exports both
(def weeks (range 35 46))
(def diffs (->>  weeks
                 (map #(vec [% (- (firsts-pmf %) (others-pmf %))]))
                 (into {})))
diffs
#+end_src

#+RESULTS:
#+begin_example
{39 -195797/2930625,
 40 -24196/20514375,
 36 154633/20514375,
 41 138983/4102875,
 43 141068/20514375,
 44 7222/20514375,
 35 80551/20514375,
 45 10634/20514375,
 38 -190217/20514375,
 42 28208/1367625,
 37 -105313/20514375}

#+end_example

#+begin_src clojure :results file :file ../weeks-diffs.svg  :exports both
(chart/histogram (chart/normalize {"diffs" diffs}) :filename "weeks-diffs.svg")
#+end_src

#+name: diffs
#+caption: diffs
#+RESULTS:
[[file:../weeks-diffs.svg]]

This figure makes the pattern clearer: first babies are less likely to be born
in week 39, and somewhat more likely to be born in weeks 41 and 42.
