#+TITLE: Chapter 3 Probability mass functions

#+begin_src clojure :results silent
(ns thinkstats2.pmfs
  (:require [clj-http.client :as client]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [tech.v3.dataset :as ds]
            [tech.v3.datatype.functional :as dfn]
            [tablecloth.api :as api]
            [thinkstats2-clj.nsfg :as nsfg]
            [thinkstats2-clj.chart :as chart])
  (:import java.util.zip.GZIPInputStream))
#+end_src

* Pmfs

Another way to represent a distribution is a *probability mass function(PMF)*,
which maps from each value to its probability.

A *probability* is a frequency expressed as a fraction of the sample size, $n$. To
get from frequencies to probabilities, we divide through by $n$, which is called
*normalization*.

We can map the division to each frequencies to get the probability:

#+begin_src clojure :results pp :exports both
(def v1 [1 2 2 3 5 ])
(def n (count v1))
(def hist (frequencies v1))
(->> hist
     (map #(vec [(first %) (/ (second %) n)]))
     (into {}))
#+end_src

#+RESULTS:
: {1 1/5, 2 2/5, 3 1/5, 5 1/5}
:

We can define a function ~probabilities~ to get the result:

#+begin_src clojure :results pp :exports both
(defn probabilities [coll]
  (let [n (count coll)]
    (->> coll
         frequencies
         (map #(vec [(first %) (/ (second %) n)]))
         (into {}))))

(probabilities [1 2 2 3 5])
#+end_src

#+RESULTS:
: {1 1/5, 2 2/5, 3 1/5, 5 1/5}
:

The ~probabilities~ is normalized so total probability is 1:

#+begin_src clojure :results pp :exports both
(->> [1 2 2 3 5]
     probabilities
     (map second)
     (reduce +))
#+end_src

#+RESULTS:
: 1N
:

In clojure implementation, ~frequencies~ and ~probabilities~ has no difference,
except that the value is integer and fraction respectively.

To look up the probability associated with a value, use the value as key:

#+begin_src clojure :results pp :exports both
(def prob (probabilities [1 2 2 3 5]))
(prob 2)
#+end_src

#+RESULTS:
: 2/5
:

You cannot modify an existing map, but you will get a new one:

#+begin_src clojure :results pp :exports both
(def prob1 (update prob 2 + 0.2))
(prob1 2)
#+end_src

#+RESULTS:
: 0.6000000000000001
:

Or you can multiply a probability by a factor:

#+begin_src clojure :results pp :exports both
(def prob2 (update prob1 2 * 0.5))
(prob2 2)
#+end_src

#+RESULTS:
: 0.30000000000000004
:


Now the the result is not normalized; that is, the probabilities no longer add
up to 1. To check, you can summarize the values:

#+begin_src clojure :results pp :exports both
(->> prob2
     (map second)
     (reduce +))
#+end_src

#+RESULTS:
: 0.8999999999999999
:

To normalize:

#+begin_src clojure :results pp :exports both
(defn normalize [probmap]
  (let [sum (->> probmap
                 (map second)
                 (reduce +))]
    (reduce #(update %1 %2 / sum) probmap (keys probmap))))
(->> (normalize prob2)
     (map second)
     (reduce +))
#+end_src

#+RESULTS:
: 1.0000000000000002
:

* Plotting PMFs

We can plot PMFs in both bar graph and step graph.

#+begin_src clojure :results none
(def fempreg-ds (nsfg/as-dataset "2002FemPreg.dct" "2002FemPreg.dat"))
(def firsts-pmf (-> fempreg-ds
                    (ds/filter #(and (= 1 (:outcome %))
                                     (= 1 (:birthord %))
                                     (< 27 (:prglngth %) 46)))
                    :prglngth
                    probabilities))
(def others-pmf (-> fempreg-ds
                    (ds/filter #(and (= 1 (:outcome %))
                                     (not= 1 (:birthord %))
                                     (< 27 (:prglngth %) 46)))
                    :prglngth
                    probabilities))
#+end_src

#+begin_src clojure :results file :output-dir figures :file first-other-prob-histogram.svg :exports both
(chart/histogram (chart/normalize {"first" firsts-pmf "other" others-pmf})
                 :filename "notes/figures/first-other-prob-histogram.svg")
#+end_src

#+RESULTS:
[[file:figures/first-other-prob-histogram.svg]]

#+begin_src clojure :results file :output-dir figures :file first-other-prob-step.svg  :exports both
(chart/step (chart/normalize {"first" firsts-pmf "other" others-pmf})
                 :filename "notes/figures/first-other-prob-step.svg")
#+end_src

#+RESULTS:
[[file:figures/first-other-prob-step.svg]]

* Other visualizations

Histograms and PMFs are useful while you are exploring data and trying to
identify patterms and relationships. Once you have an idea what is going on, a
good next step is to design a visualization that makes the patterns you have
identified as clear as possible.

Because firsts and others a quite close, it makes sense to zoom in on the
difference, as show in figure [[diffs]]:

#+begin_src clojure :results pp :exports both
(def weeks (range 35 46))
(def diffs (->>  weeks
                 (map #(vec [% (- (firsts-pmf %) (others-pmf %))]))
                 (into {})))
diffs
#+end_src

#+RESULTS:
#+begin_example
{39 -195797/2930625,
 40 -24196/20514375,
 36 154633/20514375,
 41 138983/4102875,
 43 141068/20514375,
 44 7222/20514375,
 35 80551/20514375,
 45 10634/20514375,
 38 -190217/20514375,
 42 28208/1367625,
 37 -105313/20514375}

#+end_example

#+begin_src clojure :results file :output-dir figures :file weeks-diffs.svg  :exports both
(chart/histogram (chart/normalize {"diffs" diffs}) :filename "notes/figures/weeks-diffs.svg")
#+end_src

#+name: diffs
#+caption: diffs
#+RESULTS:
[[file:figures/weeks-diffs.svg]]

This figure makes the pattern clearer: first babies are less likely to be born
in week 39, and somewhat more likely to be born in weeks 41 and 42.

* The class size paradox

Suppose that a college offers 65 classes in a given semester, with the following
distribution of sizes:

#+begin_example
 size       count
 5- 9       8
10-14       8
...
#+end_example

Here is the code, mean value is:

#+begin_src clojure :results pp :exports both
(def d {7 8, 12 8, 17 14, 22 4, 27 6, 32 12, 37 8, 42 3, 47 2})
(/ (->> d
        second
        (reduce +))
   (count d))
#+end_src

#+RESULTS:
: 11/3
:

But if you survey a group of students, ask them how many students are in their
classes, and compute the mean, you would think the average class was bigger:

#+begin_src clojure :results pp :exports both
(defn bias-pmf [pmf]
  (->> pmf
       (map #(vec [(first %) (* (second %) (first %))]))
       (into {})
       normalize))
(bias-pmf d)
#+end_src

#+RESULTS:
#+begin_example
{7 2/55,
 27 81/770,
 32 96/385,
 22 2/35,
 17 17/110,
 12 24/385,
 47 47/770,
 42 9/110,
 37 74/385}

#+end_example

For each class size, $x$, we multiply the probability by $x$, the number of
students who observe that class size. The result is a new Pmf that represents
the biased distribution.

Now we can plot the actual and observed distributions:

#+begin_src clojure :results file :output-dir figures :file bias-pmf.svg :exports both
(chart/step {"actual" (into (sorted-map) (normalize d))
             "observed" (into (sorted-map) (bias-pmf d))}
            :filename "notes/figures/bias-pmf.svg"
            :title "Class size")
#+end_src

#+RESULTS:
[[file:figures/bias-pmf.svg]]


#+begin_src clojure :results pp :exports both
(def k {5 3, 6 4, 3 2})
(into (sorted-map) k)
#+end_src

#+RESULTS:
: {3 2, 5 3, 6 4}
:

We can use the observed data and unbias the distribution:

#+begin_src clojure :results pp :exports both
(defn unbias-pmf [pmf]
  (->> pmf
       (map #(vec [(first %) (/ (second %) (first %))]))
       (into (sorted-map))
       normalize))
(unbias-pmf d)
#+end_src

#+RESULTS:
#+begin_example
{7 187311168/613351385,
 12 109264848/613351385,
 17 134974224/613351385,
 22 29799504/613351385,
 27 36421616/613351385,
 32 61461477/613351385,
 37 35437248/613351385,
 42 11706948/613351385,
 47 6974352/613351385}

#+end_example

#+begin_src clojure :results file :output-dir figures :file unbias-pmf.svg :exports both
(chart/step {"actual" (into (sorted-map) (normalize d))
             "observed" (into (sorted-map) (unbias-pmf d))}
            :filename "notes/figures/unbias-pmf.svg"
            :title "Class size")
#+end_src

#+RESULTS:
[[file:figures/unbias-pmf.svg]]
